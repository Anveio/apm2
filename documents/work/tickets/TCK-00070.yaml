ticket_meta:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"
  ticket:
    id: "TCK-00070"
    title: "Add Cross-Platform Process Checks"
  binds:
    prd_id: "NONE"
    rfc_id: "RFC-0006"
    requirements:
      - requirement_id: "MAINT-017"
        requirement_ref: "documents/rfcs/RFC-0006/01_problem_and_imports.yaml#rfc_local_requirements.requirements[11]"
    evidence_artifacts: []
  custody:
    agent_roles:
      - "AGENT_IMPLEMENTER"
    responsibility_domains:
      - "DOMAIN_BUILD_RELEASE"
  dependencies:
    tickets:
      - "TCK-00067"
  scope:
    in_scope:
      - "Add sysinfo crate to workspace Cargo.toml dependencies"
      - "Add sysinfo dependency to xtask/Cargo.toml"
      - "Replace /proc/{pid}/cmdline parsing with sysinfo::System::process()"
      - "Update is_our_process() function to use cross-platform API"
      - "Add #[cfg(target_os)] guards for any remaining platform-specific code"
      - "Document platform requirements if full cross-platform not feasible"
      - "Add tests that verify process checks work on current platform"
    out_of_scope:
      - "Windows-specific process management (signal handling differs)"
      - "Adding process management for non-Unix platforms"
      - "Changes to health monitoring thresholds"
      - "Changes to auto-remediation logic"
  plan:
    steps:
      - "Add sysinfo = \"0.31\" to workspace Cargo.toml dependencies"
      - "Add sysinfo = { workspace = true } to xtask/Cargo.toml"
      - "Locate is_our_process() function in xtask/src/reviewer_state.rs or check.rs"
      - "Replace direct /proc/{pid}/cmdline file reading with sysinfo::System::new_all()"
      - "Use system.process(Pid::from(pid)) to get process info"
      - "Check process.cmd() or process.name() for gemini or script strings"
      - "Remove all direct /proc filesystem access"
      - "Add #[cfg(unix)] guards around signal-related code (SIGTERM, SIGKILL)"
      - "Add #[cfg(not(unix))] stubs that return appropriate errors or no-ops"
      - "Document in code comments that full Windows support requires future work"
      - "Add unit test that verifies process check works for current process"
      - "Verify cargo build succeeds on current platform"
      - "Verify cargo build --target x86_64-apple-darwin succeeds (cross-compile check)"
      - "Verify cargo test passes"
      - "Verify cargo clippy passes with no warnings"
  definition_of_done:
    evidence_ids: []
    criteria:
      - "sysinfo crate added to workspace and xtask dependencies"
      - "No direct /proc filesystem access in xtask codebase"
      - "is_our_process() uses sysinfo::System::process() for process info"
      - "Process name/cmdline check uses sysinfo API, not file parsing"
      - "Signal-related code (SIGTERM, SIGKILL) has #[cfg(unix)] guards"
      - "Non-unix platforms have appropriate stubs or compile-time errors"
      - "Code compiles for macOS target (cargo build --target x86_64-apple-darwin or documented exception)"
      - "Unit tests verify process checking works on current platform"
      - "cargo build succeeds"
      - "cargo test passes"
      - "cargo clippy passes with no warnings"
  notes:
    security: |
      Cross-platform process checks ensure consistent security behavior.
      PID reuse detection is critical for preventing accidental process termination.
      sysinfo crate is widely used and well-maintained for process introspection.
    implementation_details: |
      sysinfo usage pattern (API may vary by version, verify with docs):
      ```rust
      use sysinfo::{Pid, ProcessRefreshKind, System, UpdateKind};

      fn is_our_process(pid: u32) -> bool {
          let pid = Pid::from_u32(pid);
          let mut system = System::new();
          // Refresh only the specific process with command line info
          let refresh_kind = ProcessRefreshKind::new().with_cmd(UpdateKind::Always);
          system.refresh_process_specifics(pid, refresh_kind);

          if let Some(process) = system.process(pid) {
              let cmd = process.cmd().join(" ");
              return cmd.contains("gemini") || cmd.contains("script");
          }
          false
      }
      ```

      Platform-specific signal handling:
      ```rust
      #[cfg(unix)]
      fn kill_process(pid: u32) -> Result<()> {
          use nix::sys::signal::{kill, Signal};
          use nix::unistd::Pid;
          kill(Pid::from_raw(pid as i32), Signal::SIGTERM)?;
          // ... wait and SIGKILL logic
      }

      #[cfg(not(unix))]
      fn kill_process(pid: u32) -> Result<()> {
          // Windows: use taskkill or similar
          // For now, return error indicating unsupported platform
          anyhow::bail!("Process termination not supported on this platform")
      }
      ```
    api_versioning: |
      Implementers MUST verify sysinfo crate API against the actual installed
      version (0.31.x specified in plan). The sysinfo API has changed
      significantly between versions. Key methods to verify:
      - System::new() vs System::new_all()
      - ProcessRefreshKind and UpdateKind types
      - process.cmd() return type
    affected_files: |
      Modified: Cargo.toml (workspace sysinfo dependency)
      Modified: xtask/Cargo.toml (sysinfo dependency)
      Modified: xtask/src/reviewer_state.rs (is_our_process with sysinfo)
      Modified: xtask/src/tasks/check.rs (platform guards if needed)
