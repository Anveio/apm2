# PR-branch review gate workflow
# Runs in PR-branch context (push semantics) so changes to the evaluator/reviewer
# apply immediately to the PR that introduced them.

name: Review Gate (PR Branch)

on:
  push:
    branches-ignore: [main]
  workflow_dispatch: {}

concurrency:
  group: review-gate-pr-branch-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUSTFLAGS: -D warnings
  RUST_BACKTRACE: 1

jobs:
  review-gate-pr-branch:
    name: Review Gate (PR Branch)
    runs-on: [self-hosted, linux, x64, fac-ovh]
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # stable
        with:
          toolchain: stable

      - uses: Swatinem/rust-cache@ad397744b0d591a723ab90405b7247fac0e6b8db # v2

      - name: Resolve PR context from branch
        id: pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          OWNER_REPO="${{ github.repository }}"
          OWNER="${OWNER_REPO%%/*}"
          BRANCH="${{ github.ref_name }}"

          PR_DATA=$(gh api "/repos/${OWNER_REPO}/pulls?head=${OWNER}:${BRANCH}&state=open&per_page=10")
          PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number // empty')
          if [[ -z "$PR_NUMBER" ]]; then
            echo "No open PR found for ${OWNER}:${BRANCH}; skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BASE_REF=$(echo "$PR_DATA" | jq -r '.[0].base.ref')
          HEAD_SHA=$(echo "$PR_DATA" | jq -r '.[0].head.sha')
          HEAD_REPO=$(echo "$PR_DATA" | jq -r '.[0].head.repo.full_name')

          if [[ "$HEAD_REPO" != "$OWNER_REPO" ]]; then
            echo "Refusing to run on non-local head repo: ${HEAD_REPO}"
            exit 1
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "base_ref=${BASE_REF}" >> "$GITHUB_OUTPUT"
          echo "head_sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"
          echo "pr_url=https://github.com/${OWNER_REPO}/pull/${PR_NUMBER}" >> "$GITHUB_OUTPUT"

      - name: Fetch trusted-reviewers from base branch
        if: steps.pr.outputs.skip != 'true'
        run: |
          git fetch origin "${{ steps.pr.outputs.base_ref }}" --depth=1
          git show "origin/${{ steps.pr.outputs.base_ref }}:.github/review-gate/trusted-reviewers.json" \
            > /tmp/trusted-reviewers-base.json

      - name: Run AI reviews (security + quality)
        if: steps.pr.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          cargo xtask review all "${{ steps.pr.outputs.pr_url }}"

      - name: Project ai-review statuses from trusted review comments
        if: steps.pr.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          HEAD_SHA: ${{ steps.pr.outputs.head_sha }}
        run: |
          python3 - <<'PY'
          import json
          import os
          import re
          import subprocess
          from datetime import datetime, timezone

          repo = os.environ["GITHUB_REPOSITORY"]
          pr_number = os.environ["PR_NUMBER"]
          head_sha = os.environ["HEAD_SHA"]
          trusted_reviewers_path = "/tmp/trusted-reviewers-base.json"

          def parse_iso8601(ts: str) -> datetime:
              return datetime.fromisoformat(ts.replace("Z", "+00:00")).astimezone(timezone.utc)

          def gh_api(endpoint: str):
              output = subprocess.check_output(["gh", "api", endpoint], text=True)
              return json.loads(output)

          def post_status(context: str, state: str, description: str) -> None:
              subprocess.check_call(
                  [
                      "gh",
                      "api",
                      "--method",
                      "POST",
                      f"/repos/{repo}/statuses/{head_sha}",
                      "-f",
                      f"state={state}",
                      "-f",
                      f"context={context}",
                      "-f",
                      f"description={description[:140]}",
                  ]
              )

          def trusted_logins(payload: dict, category: str) -> set[str]:
              entries = payload["reviewers"][category]
              logins: set[str] = set()
              for entry in entries:
                  for login in entry.get("github_logins", []):
                      logins.add(login.lower())
              return logins

          with open(trusted_reviewers_path, "r", encoding="utf-8") as handle:
              trusted_payload = json.load(handle)

          allowlisted = {
              "security": trusted_logins(trusted_payload, "security"),
              "code-quality": trusted_logins(trusted_payload, "code_quality"),
          }

          head_commit = gh_api(f"/repos/{repo}/commits/{head_sha}")
          head_commit_ts = parse_iso8601(head_commit["commit"]["committer"]["date"])

          comments = []
          for page in range(1, 51):
              batch = gh_api(
                  f"/repos/{repo}/issues/{pr_number}/comments?per_page=100&page={page}"
              )
              if not batch:
                  break
              comments.extend(batch)

          patterns = {
              "security": re.compile(r"(?im)^##\\s*Security Review\\s*:\\s*(PASS|FAIL)\\b"),
              "code-quality": re.compile(r"(?im)^##\\s*Code Quality Review\\s*:\\s*(PASS|FAIL)\\b"),
          }

          contexts = {
              "security": "ai-review/security",
              "code-quality": "ai-review/code-quality",
          }

          for category in ("security", "code-quality"):
              best = None
              for comment in comments:
                  body = comment.get("body") or ""
                  login = (comment.get("user") or {}).get("login", "").lower()
                  if login not in allowlisted[category]:
                      continue
                  if head_sha.lower() not in body.lower():
                      continue

                  timestamp_raw = comment.get("updated_at") or comment.get("created_at")
                  if not timestamp_raw:
                      continue
                  timestamp = parse_iso8601(timestamp_raw)
                  if timestamp < head_commit_ts:
                      continue

                  verdict_match = patterns[category].search(body)
                  if not verdict_match:
                      continue

                  verdict = verdict_match.group(1).upper()
                  if verdict not in ("PASS", "FAIL"):
                      continue

                  rank = (timestamp, int(comment.get("id", 0)))
                  if best is None or rank > best["rank"]:
                      best = {
                          "rank": rank,
                          "comment_id": int(comment.get("id", 0)),
                          "state": "success" if verdict == "PASS" else "failure",
                          "description": f"{category} review {verdict} (comment #{int(comment.get('id', 0))})",
                      }

              if best is None:
                  state = "pending"
                  description = (
                      f"Waiting for trusted {category} verdict on {head_sha[:12]}"
                  )
              else:
                  state = best["state"]
                  description = best["description"]

              context = contexts[category]
              print(
                  json.dumps(
                      {
                          "context": context,
                          "state": state,
                          "description": description,
                          "category": category,
                      }
                  )
              )
              post_status(context, state, description)
          PY

      - name: Evaluate review gate
        id: evaluate
        if: steps.pr.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set +e
          cargo xtask review-gate \
            --repo "${{ github.repository }}" \
            --pr-number "${{ steps.pr.outputs.pr_number }}" \
            --head-sha "${{ steps.pr.outputs.head_sha }}" \
            --trusted-reviewers "/tmp/trusted-reviewers-base.json" \
            | tee /tmp/review-gate-evaluation.json
          code=$?
          set -e

          if [ "$code" -eq 0 ]; then
            state="success"
            description="Review gate passed"
            exit_code=0
          elif [ "$code" -eq 2 ]; then
            state="pending"
            description="Waiting for AI reviews"
            exit_code=0
          else
            if jq -e '.security.authoritative_verdict == "FAIL" or .code_quality.authoritative_verdict == "FAIL"' \
              /tmp/review-gate-evaluation.json >/dev/null 2>&1; then
              state="failure"
              description="Review gate failed"
              exit_code=1
            else
              state="pending"
              description="Waiting for AI reviews"
              exit_code=0
            fi
          fi

          echo "state=${state}" >> "$GITHUB_OUTPUT"
          echo "description=${description}" >> "$GITHUB_OUTPUT"
          exit "$exit_code"

      - name: Post review gate status to PR head
        if: always() && steps.pr.outputs.skip != 'true' && steps.pr.outputs.head_sha != ''
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          state="${{ steps.evaluate.outputs.state || 'pending' }}"
          description="${{ steps.evaluate.outputs.description || 'Waiting for AI reviews' }}"
          gh api --method POST "/repos/${{ github.repository }}/statuses/${{ steps.pr.outputs.head_sha }}" \
            -f state="${state}" \
            -f context="Review Gate Success" \
            -f description="${description}"

